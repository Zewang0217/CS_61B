### 项目2：CS61BYoG

#### 说明
本部分将涵盖我们认为在原始规范中不够清晰的任何细节。将其置于顶部以便于查看。

对于第一阶段，你的游戏不一定需要支持 `playWithKeyboard()` 方法，但必须支持 `playWithInputString()` 方法的一部分。具体来说，你应该能够使用一个输入字符串来玩你的游戏，该字符串可以开始一个新游戏、输入一个种子、开始游戏/生成世界，然后返回表示此时世界状态的数组。这基本上意味着你必须支持任何格式为 “N#######S” 的字符串，其中每个 `#` 都是一个数字，并且 `#` 的数量可以是任意的。

输入字符串中的字母可以是大写或小写，并且你的游戏应该能够接受任意一种按键输入（即，“N” 和 “n” 都应该从菜单屏幕开始一个新游戏）。

如果玩家尝试加载一个之前没有保存过的游戏，你的游戏应该结束，并且游戏窗口应该关闭，且不产生任何错误。

在基本要求中，命令 “:Q” 应该保存并完全终止程序。这意味着包含 “:Q” 的输入字符串后面不应该再有任何字符，并且加载游戏需要再次运行程序，并使用以 “L” 开头的输入字符串。

你的游戏应该能够处理任何不超过 9,223,372,036,854,775,807 的正种子。

当使用 `playWithInputString()` 方法时，你的游戏不应该渲染任何图块或播放任何声音。

`StdDraw` 不支持组合键。当我们说 “:Q” 时，我们指的是先按 “:” 然后按 “Q”。

你的项目应该只使用标准的 Java 库（从 `java.*` 导入）或我们在你的代码仓库中提供的任何库。这仅与自动评分器相关，所以如果你想为了获得额外加分（Gold Points）以及在展示视频中使用其他库，你可以自由使用。

你创建的任何 `TETile` 对象都应该被赋予一个其他图块未使用的唯一字符。即使你使用自己的图像来渲染图块，每个 `TETile` 仍然应该有其自己的字符表示。

你可以创建的唯一文件必须具有后缀 “.txt”（例如 “savefile.txt”）。如果你不这样做，你的自动评分将会出现问题。

#### 简介
在项目 2 中，你将创建一个用于生成可探索世界的引擎，为了方便表述，我们将其称为 “游戏”。这是一个大型设计项目，需要你和一位合作伙伴完成从构思到展示的每个开发阶段。本项目的目标是教你如何处理较大规模的代码，且只有很少的起始代码，希望能模拟类似产品开发周期的过程。与此相符，本项目的评分方式将与其他项目不同。由于在游戏设计和实现方面没有 “正确答案” 的概念，除了非常通用的自动评分器外，你将像在实习或工作中接受绩效评估一样接受评估。虽然这意味着评分会有一点主观性，但我们保证会是很好的 “老板”，并且会像任何老板尊重努力工作的员工一样尊重你。如果你觉得评分方案不公平，请与我们沟通。

可以在这个链接找到讨论如何完成本项目的视频播放列表。这些视频的幻灯片可以在这个链接找到。

本作业有几个关键的截止日期：
- 阶段 0：组队：于 2 月 16 日星期五，随实验课一起提交。
  - 组队表格
  - 如果你真的想独自完成，可以使用单人表格，但不建议这样做。
- 阶段 1：世界生成：于 2 月 26 日晚上 11:59 在 gradescope 上提交。在 2 月 23 日之前完成可获得 6 分的额外加分。
- 阶段 2：可玩游戏：于 3 月 5 日晚上 11:59 在 gradescope 上提交。
- 实验演示：在 3 月 7 日、3 月 8 日或 3 月 9 日的实验课上演示你的项目。演示时段的报名信息将稍后发布。
- 额外加分（Gold Points）：为你的游戏添加创意机制，并在 3 月 9 日前在 YouTube 上创建一个公开视频展示你所构建的内容。

现在开始介绍作业规范！

#### 概述
在接下来的 3 周里，你的任务是设计并实现一个基于 2D 图块的游戏。所谓 “基于图块”，是指你的游戏世界将由一个 2D 图块网格组成。所谓 “游戏”，是指玩家将能够在世界中四处走动并与世界进行交互。你的游戏将采用俯视视角。作为一个比你要构建的游戏复杂得多的示例，NES 游戏《塞尔达传说 II》（有时）就是一个基于图块的俯视游戏：

[塞尔达传说 II 游戏示例图片（Zelda2）]

![31358-zelda-ii-the-adventure-of-link-nes-screenshot-an-overhead-view](D:\Zewang\CS_61B\Note\31358-zelda-ii-the-adventure-of-link-nes-screenshot-an-overhead-view.jpg)

你构建的游戏可以使用图形图块（如上图所示），也可以使用基于文本的图块，就像下面展示的游戏：

[brogue 游戏示例图片（brogue）]



我们将提供一个图块![brogue_textbased_example](D:\Zewang\CS_61B\Note\brogue_textbased_example.png)渲染引擎、一小部分起始图块，以及一些你的游戏必须实现且自动评分器会使用的方法的头文件。本项目将有两个主要的截止日期。在第一个截止日期前，你应该能够生成符合以下标准的随机世界。在第二个截止日期前，玩家应该能够探索并与世界进行交互。

本项目的主要目标是给你一个机会，尝试管理构建大型系统时带来的巨大复杂性。请注意：你构建的游戏可能不会很有趣！三周的时间实在不够，尤其是对于新手程序员来说。然而，我们确实希望你会觉得这是一个有成就感的项目，而且你生成的世界甚至可能很漂亮。

#### 框架代码结构
框架代码包含两个你将使用的关键包：`byog.TileEngine` 和 `byog.Core`。`byog.TileEngine` 提供了一些基本的渲染方法，以及图块的基本代码结构，并且包含：
- `TERenderer.java` - 包含与渲染相关的方法。
- `TETile.java` - 用于表示世界中图块的类型。
- `Tileset.java` - 提供的图块库。

**重要提示**：请勿更改 `TETile.java` 的 `charcter` 字段或 `character()` 方法，因为这可能会导致自动评分结果不佳。

另一个包 `byog.Core` 包含所有与图块无关的内容。我们建议你将所有游戏代码放在这个包中，不过这不是必需的。`byog.Core` 包带有以下类：
- `RandomUtils.java` - 用于处理与随机性相关事情的便捷实用方法。
- `Main.java` - 玩家如何启动游戏。读取命令行参数并调用 `Game.java` 中的适当函数。
- `Game.java` - 包含两个允许玩你的游戏的方法。

`byog.Core.Game` 提供了两个玩你的游戏的方法。第一个是 `public TETile[][] playWithInputString(String input)`。这个方法接受一系列键盘输入作为输入，并返回一个 2D `TETile` 数组，表示在处理输入中提供的所有按键操作后宇宙的状态（如下所述）。第二个是 `public void playWithKeyboard()`。这个方法从键盘获取输入，并将每次按键的结果绘制到屏幕上。

游戏引擎大量使用了 `StdDraw`。在项目的某些时候，你可能需要查阅 `StdDraw` 的 API 规范，可以在这里找到。

#### 阶段 1：世界生成
如前所述，本项目的第一个目标是编写一个世界生成器。你的世界的要求如下：
- 世界必须是一个 2D 网格，使用我们的图块引擎绘制。图块引擎在实验 5 中进行了描述。
- 世界必须是伪随机生成的。伪随机性在实验 5 中进行了讨论。
- 生成的世界必须包括房间和走廊，不过也可以包括户外空间。
- 至少有一些房间应该是矩形的，不过你也可以支持其他形状。
- 你的游戏必须能够生成包括转弯的走廊（或者等效地，相交的直走廊）。
- 世界应该包含随机数量的房间和走廊。
- 房间和走廊的位置应该是随机的。
- 房间的宽度和高度应该是随机的。
- 走廊的长度应该是随机的。
- 房间和走廊必须有与地板在视觉上不同的墙壁。墙壁和地板应该与未使用的空间在视觉上不同。
- 房间和走廊应该是相连的，即相邻房间或走廊之间的地板上不应该有间隙。
- 每次生成的世界应该有很大的不同，即你不应该有具有容易预测特征的相同基本布局。

作为一个满足所有这些要求的世界的示例（点击查看更高分辨率），请见下面的图片。在这张图片中，`#` 表示墙壁，`.` 表示地板，还有一个金色的墙壁段表示一扇锁着的门。所有未使用的空间留空。

[符合要求的世界示例图片（compliant_world_example）]

![compliant_world_example](D:\Zewang\CS_61B\Note\compliant_world_example.png)

一旦你完成了实验 5，你就可以开始处理你的世界生成算法，而无需阅读或理解本规范的其余部分。

很有可能你最终会放弃你的第一个世界生成算法。这是正常的！在现实世界的系统中，在得到你满意的结果之前，构建几个全新的版本是很常见的。上面的房间生成算法是我的第三个，并且最终比我的前两个都要简单得多。

你可以在网上搜索很酷的世界生成算法。你不应该从现有的游戏中复制粘贴代码，但你可以从网上的代码中获取灵感。确保使用 `@source` 标签注明你的来源。你也可以尝试玩现有的 2D 基于图块的游戏以获取灵感。`Brogue` 是一个特别优雅、漂亮的游戏示例。《矮人要塞》是一个极其复杂、荒谬复杂的世界生成引擎的示例。

#### 默认图块集和图块渲染引擎
我们提供的图块渲染引擎接受一个 `TETile` 对象的 2D 数组并将其绘制到屏幕上。我们暂时将其称为 `TETile[][] world`。`world[0][0]` 对应世界的左下角图块。第一个坐标是 x 坐标，例如 `world[9][0]` 指的是从左下角图块向右 9 个位置的图块。第二个坐标是 y 坐标，并且当我们向上移动时该值会增加，例如 `world[0][5]` 是从左下角图块向上 5 个图块的位置。所有值都应该是非空的，即在调用 `renderFrame` 之前确保将它们全部填充。确保你理解世界网格的方向！如果你不确定，可以编写简短的示例程序来绘制到网格上以加深你的理解。如果你混淆了 x 与 y 或者上与下，你在调试时将会非常困惑。

我们在 `Tileset.java` 中提供了一小部分默认图块，这些应该作为如何创建 `TETile` 对象的一个很好的示例。我们强烈建议你也添加自己的图块。

图块引擎也支持图形图块！要使用图形图块，只需将图块的文件名作为第五个参数提供给 `TETile` 构造函数。图像必须是 16 x 16 的，并且理想情况下应该是 PNG 格式。网上有大量用于基于图块游戏的开源图块集。你可以自由使用这些。注意：你的 GitHub 账户设置为拒绝除了 `.txt` 或 `.java` 文件之外的其他文件。在运行你的代码时，我们将无法访问你的图块。如果你想为了存档目的保留带有图形的项目副本，请确保在 GitHub 之外的其他地方保留你项目的副本。图形图块不是必需的。

如果你不提供文件名或者文件无法打开，那么图块引擎将改为使用提供的 Unicode 字符。这意味着如果其他人在本地没有你指定位置的图像文件，游戏仍然可以玩，但将使用 Unicode 字符而不是你选择的纹理。

图块渲染引擎依赖于 `StdDraw`。我们建议除非你真的知道自己在做什么，否则不要使用 `StdDraw` 的命令，如 `setXScale` 或 `setYScale`，否则你可能会极大地改变或破坏游戏的美观性。

#### 启动游戏
你的游戏必须支持两种启动方式，一种是使用 `Core.Game.playWithKeyboard()` 方法，另一种是使用 `Core.Game.playWithInputSting(String s)` 方法。

当运行你的 `Core.Game.playWithKeyboard()` 方法时，你的游戏必须显示一个主菜单，该菜单至少提供开始新游戏、加载先前保存的游戏和退出游戏的选项。主菜单应该只能使用键盘进行导航，使用 `N` 表示 “新游戏”，`L` 表示 “加载游戏”，`Q` 表示退出。你可以包括其他选项。

[主菜单示例图片（mainmenu_example）]

![mainmenu_example](D:\Zewang\CS_61B\Note\mainmenu_example.png)

在按下 `N` 表示 “新游戏” 后，用户应该被提示输入一个 “随机种子”，这是一个他们选择的整数。这个整数将用于随机生成世界（如后面和实验 5 中所述）。在用户按下他们种子中的最后一个数字后，他们应该按下 `S` 告诉游戏他们已经输入了他们想要的整个种子。

“加载” 命令的行为在本规范的其他地方进行了描述。

如果游戏是使用 `Core.Game.playWithInputString()` 启动的，则不应显示菜单，也不应在屏幕上绘制任何内容。否则，游戏应该像人类玩家使用 `Core.Game.playWithKeyboard()` 方法按下给定的键一样处理给定的字符串。例如，如果我们调用 `Core.Game.playWithInputString("N3412S")`，游戏应该使用种子 3412 生成一个世界，并返回生成的 2D 图块数组。

我们建议你在项目的第二阶段（交互性）之前不要实现 `Core.Game.playWithKeyboard()` 方法，不过你可以在任何时候实现它。使用 `playWithInputString` 来测试和调试你的世界生成器会更容易。

如果你想让用户有其他选项，例如能够选择他们角色的属性、指定世界生成参数等，你应该创建其他选项。例如，如果你想让用户能够选择扮演哪种生物，你可以在主菜单中添加第四个选项 `S` 表示 “选择生物并开始新游戏”。这些其他选项可以有你选择的任意行为。`N`、`L` 和 `Q` 的行为必须完全符合规范中的描述！

#### 阶段 2：交互性
在游戏的第二阶段，你将添加用户实际玩游戏的能力，并且还将为你的游戏添加用户界面（UI）元素，使其感觉更具沉浸感和信息性。

交互性的要求如下：
- 玩家必须能够控制某种可以使用 `W`、`A`、`S` 和 `D` 键在世界中移动的实体。实验 6 涵盖了如何在你的游戏中包含交互性。
- 该实体必须能够以某种方式与世界进行交互。
- 你的游戏必须是确定性的，即从相同的种子出发，相同的按键序列每次都必须产生完全相同的行为。如果你使用伪随机生成器是可以的，因为 `Random` 对象保证每次输出相同的随机数。
- 可选地，你也可以包括允许玩家获胜或失败的游戏机制（见下面的额外加分）。除了这些功能要求之外，你的游戏还有一些技术要求，下面将详细描述。

#### 游戏用户界面（UI）外观
在用户输入种子并按下 `S` 后，游戏应该开始。游戏的用户界面必须包括：
- 显示世界当前状态的 2D 图块网格。
- 一个 “抬头显示”（Heads Up Display，HUD），提供可能对用户有用的其他信息。至少，这应该包括描述鼠标指针当前下方图块的文本。

作为最低要求的一个示例，下面的游戏显示了一个图块网格和一个 HUD，该 HUD 显示鼠标指针下方图块的描述（点击图片查看更高分辨率）：

[鼠标悬停示例 1 图片（mouseover_example1）]

![UI_example0](D:\Zewang\CS_61B\Note\UI_example0.png)

如果你选择，你可以包括其他功能。在下面的示例中（点击图片查看更高分辨率），与前面的示例一样，鼠标光标当前在一个墙壁上，所以 HUD 在右上角显示文本 “wall”。然而，这个游戏的 HUD 还为用户提供了 5 颗心，表示玩家的 “生命值”。请注意，这个游戏不符合上述规范的要求，因为它是一个很大的、不规则的洞穴空间，而不是由走廊连接的房间。

[鼠标悬停示例 1 图片（mouseover_example1）]

![UI_example1](D:\Zewang\CS_61B\Note\UI_example1.png)

作为一个示例，下面的游戏（点击图片查看更高分辨率）使用 GUI 列出了其他有效的按键，并在用户鼠标悬停在图块上时提供更详细的信息（“你看到类似草的真菌。”）。下面显示的图片是一个专业游戏，你的游戏不期望看起来有那么好。

[鼠标悬停示例 2 图片（mouseover_example2）]

![UI_example2](D:\Zewang\CS_61B\Note\UI_example2.png)

有关如何指定 HUD 位置的信息，请参阅 `TERenderer` 的 `initialize(int width, int height, int xOffset, int yOffset)` 方法，或参阅实验 6。

#### 游戏用户界面（UI）行为
当游戏开始时，用户必须能够控制某种显示在世界中的实体。用户必须能够分别使用 `W`、`A`、`S` 和 `D` 键向上、向左、向下和向右移动。这些键也可以做其他事情，例如推动物体。你可以在你的游戏中包括其他键。用户不能使用鼠标点击与世界进行交互，例如，不能点击来允许移动。

游戏必须表现为伪随机的。也就是说，给定某个种子，相同的一组按键必须产生完全相同的结果！

除了移动键之外，如果用户输入 “:Q”，游戏应该退出并保存。保存（和加载）功能的描述在下一节中。这个命令必须立即退出并保存，并且不需要进一步的按键来完成，例如，在退出之前不要询问他们是否确定。我们